
#Область ПрограммныйИнтерфейс

// Определяет схему ссылки.
//
// Параметры:
//  Href - Строка - Проверяемая ссылка.
// 
// Возвращаемое значение:
//  Строка - Схема ссылки.
//
Функция ОпределитьСхемуСсылки(Href) Экспорт

	Если СтрокаНачинаетсяСПодстроки(Href, "v8doc:") Тогда
		Возврат "v8doc:";

	ИначеЕсли СтрокаНачинаетсяСПодстроки(Href, "http://") Тогда
		Возврат "http://";

	ИначеЕсли СтрокаНачинаетсяСПодстроки(Href, "https://") Тогда
		Возврат "https://";

	ИначеЕсли СтрокаНачинаетсяСПодстроки(Href, "ftp://") Тогда
		Возврат "ftp://";

	ИначеЕсли СтрокаНачинаетсяСПодстроки(Href, "mailto:") Тогда
		Возврат "mailto:";
		
	ИначеЕсли СтрокаНачинаетсяСПодстроки(Href, "tel:") Тогда
		Возврат "tel:";
		
	ИначеЕсли СтрНайти(Href, "e1cib/data") Тогда
		Возврат "e1cib/data";
		
	Иначе
		
		Возврат "";

	КонецЕсли;

КонецФункции

// Заменяет в строке все спецсимволы на соответствующие им имена,
//  Возвращает измененную строку.
//
// Параметры:
//  Строка           - Строка       - Анализируемая строка;
//  СпецСимволыСоотв - Соответствие - Список спец символов, которые нужно заменить.
// 
// Возвращаемое значение:
//  Строка - Преобразованная исходная строка.
//
Функция ЗаменитьСпецСимволыHTML(Строка, СпецСимволыСоотв = Неопределено) Экспорт

	СоответствиеСпецСимволов = РаботаСHTMLВызовСервераПовтИсп.ПолучитьСпецСимволыВВидеПарыКодПредставление();

	ЗаменитьСпецСимволHTML(Строка, 38, "amp");

	НоваяСтрока = Строка;
	Для Каждого Пара Из СоответствиеСпецСимволов Цикл
		НоваяСтрока = СтрЗаменить(Строка, Пара.Ключ, "&" + Пара.Значение + ";");
	КонецЦикла;

	Строка = НоваяСтрока;

	Возврат Строка;

КонецФункции

// Заменяет в строке все имена спецсимволов на соответствующие им спецсимволы,
//  Возвращает измененную строку.
//
// Параметры:
//  Строка           - Строка       - Анализируемая строка;
//  СпецСимволыСоотв - Соответствие - Список спец символов, которые нужно заменить.
// 
// Возвращаемое значение:
//  Строка - Преобразованная исходная строка.
//
Функция ЗаменитьСпецСимволыHTMLОбратно(Строка, СпецСимволыСоотв = Неопределено) Экспорт

	ОбратноеСоответствиеСпецСимволов = 
		РаботаСHTMLВызовСервераПовтИсп.ПолучитьСпецСимволыВВидеПарыКодПредставление();

	ЗаменитьСпецСимволHTMLОбратно(Строка, 38, "amp");

	Для Каждого СпецСимвол Из ОбратноеСоответствиеСпецСимволов Цикл
		Строка = СтрЗаменить(Строка, "&" + СпецСимвол.Значение + ";", Символ(СпецСимвол.Ключ));
	КонецЦикла;

	Возврат Строка;

КонецФункции

// Заменяет символы табуляции и пробелов на символ неразрывного пробела
//
// Параметры:
//  Строка - Строка - Изменяемая строка HTML текста.
//
Процедура ЗаменитьТабуляцииИПробелы(Строка) Экспорт

	Строка = СтрЗаменить(Строка, Символы.ВТаб, "    ");
	Строка = СтрЗаменить(Строка, Символы.Таб, "    ");
	Строка = СтрЗаменить(Строка, "  ", Символы.НПП + " ");
	Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
	Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
	Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
	Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
	Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);
	Строка = СтрЗаменить(Строка, Символы.НПП + " " + Символы.НПП, Символы.НПП + Символы.НПП + Символы.НПП);

КонецПроцедуры

// Добавляет теги ко всем ссылкам, находящимся в строке.
//  Обрабатываются следующие схемы обращения к ресурсу:
//  http://, https://, ftp://, mailto:, file://, file:, e1c://, e1cib/
//  Кроме того обрабатываются с использованием схемы http:// ссылки начинающиеся с www. без схемы.
//
// Параметры:
//  ТекстHTML - Строка - Преобразуемый HTML текст.
//
Процедура ДобавитьТегиКСсылкам(ТекстHTML) Экспорт

	// Ссылки со схемой
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "http://");
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "https://");
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "ftp://");
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "e1cib/data");
	
	// Ссылки без схемы
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "www.", "http://www.");
	ДобавитьТегиКСсылкамСоСхемой(ТекстHTML, "mailto:");

	// Заполнить title у ссылок
	ЗаполнитьСвойствоTitleУСсылок(ТекстHTML);

КонецПроцедуры

// Проверяет нахождение переданной позиции внутри тега (в параметрах или содержании)
// Если тег не закрыт, то проверяет только в параметрах тега.
//
// Параметры:
//  ТекстHTML        - Строка - Анализируемый HTML текст;
//  НазваниеЭлемента - Строка - Название искомого элемента;
//  Позиция          - Число  - Начальная позиция, с которой необходимо искать тег;
//  Тег              - Строка - HTML тег.
// 
// Возвращаемое значение:
//  Булево - Истина, если искомая позиция находится по тексту внутри указанного тега.
//
Функция ПозицияНаходитсяВТеге(ТекстHTML, НазваниеЭлемента, Позиция, Тег = Неопределено) Экспорт

	НачалоОткрывающегоТега = "<" + НРег(НазваниеЭлемента);
	ДлинаОткрывающегоТега  = СтрДлина(НачалоОткрывающегоТега);
	ПозицияНаходитсяВТеге  = Ложь;

	НачалоТекстаHTML = Лев(НРег(ТекстHTML), Позиция - 1);
	НайденнаяПозицияНачалаОткрывающегоТега = 0;
	ПозицияОкончанияОткрывающегоТега       = 0;

	ПозицияНачалаОткрывающегоТега = СтрНайти(НачалоТекстаHTML, НачалоОткрывающегоТега);
	Пока ПозицияНачалаОткрывающегоТега <> 0 Цикл

		НачалоТекстаHTML = Сред(НачалоТекстаHTML, ПозицияНачалаОткрывающегоТега + 1);
		НайденнаяПозицияНачалаОткрывающегоТега =
			НайденнаяПозицияНачалаОткрывающегоТега
			+ ПозицияОкончанияОткрывающегоТега
			+ ПозицияНачалаОткрывающегоТега;

		ПозицияОкончанияОткрывающегоТега = СтрНайти(НачалоТекстаHTML, ">");
		Если ПозицияОкончанияОткрывающегоТега <> 0 Тогда
			НачалоТекстаHTML = Сред(НачалоТекстаHTML, ПозицияОкончанияОткрывающегоТега + 1);
		КонецЕсли;

		ПозицияНачалаОткрывающегоТега = СтрНайти(НачалоТекстаHTML, НачалоОткрывающегоТега);

	КонецЦикла;
	
	Если НайденнаяПозицияНачалаОткрывающегоТега <> 0 Тогда

		// Если есть незакрытый открывающий тег до искомой позиции, ищем тег в исходном тексте HTML.
		Тег = ПолучитьТегВТекстеHTML(ТекстHTML, НазваниеЭлемента, НайденнаяПозицияНачалаОткрывающегоТега);

		Если ЗаполненаСтруктураТега(Тег) Тогда

			Если Позиция > Тег.ПозицияНачалаТега И Позиция < Тег.ПозицияОкончанияТега Тогда
				ПозицияНаходитсяВТеге = Истина;
			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	Возврат ПозицияНаходитсяВТеге;

КонецФункции

// Возвращает пустое HTML представление.
// 
// Возвращаемое значение:
//  Строка - Пустой HTML документ.
//
Функция ПолучитьПустоеHTMLПредставление() Экспорт

	Возврат "<html><body></body></html>";

КонецФункции

Функция ПолучитьHTMLИзТекста(Знач Текст, ШиринаКлиента = "device-width") Экспорт
	
	Текст = СтрЗаменить(Текст, Символы.ПС, "<br/>");
	
	ТекстHTML = СтрШаблон(
		"<html>
		|<head>
		|<meta name=""viewport"" content=""width= %1, initial-scale=1""/>
		|<meta http-equiv=""content-type"" content=""text/html; charset=UTF-8""/>
		|</head>
		|<body>
		|<div style=""font-family:Arial;font-size:12px; overflow-y: scroll;"">
		|%2
		|</div>
		|<br/>
		|</body>
		|</html>", ШиринаКлиента, Текст);
		
	Возврат ТекстHTML;
	
КонецФункции

// Преобразовывает HTML текст в текст
Функция HTMLВТекст(Знач ТекстHTML, Знач Кодировка = Неопределено, Знач ВыделятьСсылки = Истина) Экспорт
	
	// если текст не содержит html тега, то его преобразовывать не нужно
	Если СтрНайти(ТекстHTML, "<html") = 0 Тогда
		Возврат ТекстHTML;
	КонецЕсли;
	
	ПереводСтроки = Символы.ВК + Символы.ПС;
	
	ТекстHTML = СтрЗаменить(ТекстHTML, Символы.ПС, "");
	ТекстHTML = СтрЗаменить(ТекстHTML, "</o:p>", "</o:p>" + ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</o:p>" + ПереводСтроки + ПереводСтроки, "</o:p>" + ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</p>", "</p>" + ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</p>" + ПереводСтроки + ПереводСтроки, "</p>" + ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "</div>" + ПереводСтроки + ПереводСтроки, "</div>" + ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "<div>" + "</div>", ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "<div><br></div>", ПереводСтроки + ПереводСтроки);
	ТекстHTML = СтрЗаменить(ТекстHTML, "<br>", ПереводСтроки);
	
	Построитель = Новый ПостроительDOM;
	ЧтениеHTML = Новый ЧтениеHTML;
	Если ЗначениеЗаполнено(Кодировка) Тогда
		Попытка
			ЧтениеHTML.УстановитьСтроку(ТекстHTML, Кодировка);
		Исключение	
			ЧтениеHTML.УстановитьСтроку(ТекстHTML); // кодировка могла быть некорректная - ставим без кодировки
		КонецПопытки;	
	Иначе
		ЧтениеHTML.УстановитьСтроку(ТекстHTML);
	КонецЕсли;
	
	ДокументHTML = Построитель.Прочитать(ЧтениеHTML);
	
	Если ДокументHTML.Тело = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Результат = ДокументHTML.Тело.ТекстовоеСодержимое;
	
	Возврат Результат;
	
КонецФункции


#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// "margin-left:-8pt";
Процедура КорректироватьОтрицательныеОтступыСлева_Выполнить(ТекстПисьма) Экспорт
	
	ТекстПисьмаДляПравки = ТекстПисьма;
	
	НачальнаяПозиция = 1;
	
	// найдем позицию body
	ТекстПисьмаДляПравкиНРег = НРег(ТекстПисьмаДляПравки);
	ПозицияНачалаBody = СтрНайти(ТекстПисьмаДляПравкиНРег, "<body");
	Если ПозицияНачалаBody <> 0 Тогда
		НачальнаяПозиция = ПозицияНачалаBody;
	КонецЕсли;	
	
	Если ПозицияНачалаBody <> 0 Тогда
		НачальнаяПозиция = ПозицияНачалаBody;
	КонецЕсли;	
	
	ЧислоИтераций = 0;
	Пока Истина Цикл
		
		ЧислоИтераций = ЧислоИтераций + 1;
		Если ЧислоИтераций > 10000 Тогда
			Прервать;
		КонецЕсли;	
		
		// сперва Позиция_msocommentreference, потом msocomanchor
		// между ними - font-size:8.0pt
		
		СтрокаПоиска1 = "margin-left:-";
		СтрокаПоиска2 = "margin-left: -";
		
		ПозицияМинус = 0;
		
		Позиция_1 = СтрНайти(ТекстПисьмаДляПравкиНРег, СтрокаПоиска1,,НачальнаяПозиция);
		Позиция_2 = СтрНайти(ТекстПисьмаДляПравкиНРег, СтрокаПоиска2,,НачальнаяПозиция);
		
		Если Позиция_1 = 0 И Позиция_2 = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Если Позиция_1 <> 0 И Позиция_2 = 0 Тогда
			ПозицияМинус = Позиция_1 + СтрДлина(СтрокаПоиска1) - 1;
		ИначеЕсли Позиция_1 = 0 И Позиция_2 <> 0 Тогда
			ПозицияМинус = Позиция_2 + СтрДлина(СтрокаПоиска2) - 1;
		ИначеЕсли Позиция_1 <> 0 И Позиция_2 <> 0 Тогда	
			
			Если Позиция_1 < Позиция_2 Тогда // используем поз 1
				ПозицияМинус = Позиция_1 + СтрДлина(СтрокаПоиска1) - 1;
			Иначе
				ПозицияМинус = Позиция_2 + СтрДлина(СтрокаПоиска2) - 1;
			КонецЕсли;
			
		КонецЕсли;
		
		// ищем  либо p, либо ;'" что раньше (не более 30)
		НашлиP = Ложь;
		ПозицияP = 0;
		ДлинаТекста = СтрДлина(ТекстПисьмаДляПравкиНРег);
		
		Для Поз = 1 По 30 Цикл
			
			Если ПозицияМинус + Поз > ДлинаТекста Тогда 
				Прервать;
			КонецЕсли; 	
			
			Символ = Сред(ТекстПисьмаДляПравкиНРег, ПозицияМинус + Поз, 1);
			Если Символ = "p" Тогда
				НашлиP = Истина;
				ПозицияP = ПозицияМинус + Поз;
				Прервать;
			КонецЕсли; 	
			
			Если Символ = ";" Или Символ = "'" Или Символ = """" Тогда
				Прервать;
			КонецЕсли; 	
			
		КонецЦикла;	
		
		Если НашлиP Тогда
			
			ТекстПисьмаДляПравки = Лев(ТекстПисьмаДляПравки, ПозицияМинус - 1)
				+ "0"
				+ Сред(ТекстПисьмаДляПравки, ПозицияP);
				
			ТекстПисьмаДляПравкиНРег = НРег(ТекстПисьмаДляПравки);
		
		КонецЕсли;
		
		НачальнаяПозиция = ПозицияМинус + 1;
		Продолжить;
			
	КонецЦикла;
	
	ТекстПисьма = ТекстПисьмаДляПравки;
	
КонецПроцедуры	

// "text-indent:-";
Процедура КорректироватьОтрицательныеИнденты_Выполнить(ТекстПисьма) Экспорт
	
	ТекстПисьмаДляПравки = ТекстПисьма;
	
	НачальнаяПозиция = 1;
	
	// найдем позицию body
	ТекстПисьмаДляПравкиНРег = НРег(ТекстПисьмаДляПравки);
	ПозицияНачалаBody = СтрНайти(ТекстПисьмаДляПравкиНРег, "<body");
	Если ПозицияНачалаBody <> 0 Тогда
		НачальнаяПозиция = ПозицияНачалаBody;
	КонецЕсли;	
	
	Если ПозицияНачалаBody <> 0 Тогда
		НачальнаяПозиция = ПозицияНачалаBody;
	КонецЕсли;	
	
	ЧислоИтераций = 0;
	Пока Истина Цикл
		
		ЧислоИтераций = ЧислоИтераций + 1;
		Если ЧислоИтераций > 10000 Тогда
			Прервать;
		КонецЕсли;	
		
		// сперва Позиция_msocommentreference, потом msocomanchor
		// между ними - font-size:8.0pt
		
		СтрокаПоиска1 = "text-indent:-";
		СтрокаПоиска2 = "text-indent: -";
		
		ПозицияМинус = 0;
		
		Позиция_1 = СтрНайти(ТекстПисьмаДляПравкиНРег, СтрокаПоиска1,,НачальнаяПозиция);
		Позиция_2 = СтрНайти(ТекстПисьмаДляПравкиНРег, СтрокаПоиска2,,НачальнаяПозиция);
		
		Если Позиция_1 = 0 И Позиция_2 = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Если Позиция_1 <> 0 И Позиция_2 = 0 Тогда
			ПозицияМинус = Позиция_1 + СтрДлина(СтрокаПоиска1) - 1;
		ИначеЕсли Позиция_1 = 0 И Позиция_2 <> 0 Тогда
			ПозицияМинус = Позиция_2 + СтрДлина(СтрокаПоиска2) - 1;
		ИначеЕсли Позиция_1 <> 0 И Позиция_2 <> 0 Тогда	
			
			Если Позиция_1 < Позиция_2 Тогда // используем поз 1
				ПозицияМинус = Позиция_1 + СтрДлина(СтрокаПоиска1) - 1;
			Иначе
				ПозицияМинус = Позиция_2 + СтрДлина(СтрокаПоиска2) - 1;
			КонецЕсли;
			
		КонецЕсли;
		
		// ищем  либо p, либо ;'" что раньше (не более 30)
		НашлиP = Ложь;
		ПозицияP = 0;
		ДлинаТекста = СтрДлина(ТекстПисьмаДляПравкиНРег);
		
		Для Поз = 1 По 30 Цикл
			
			Если ПозицияМинус + Поз > ДлинаТекста Тогда 
				Прервать;
			КонецЕсли; 	
			
			Символ = Сред(ТекстПисьмаДляПравкиНРег, ПозицияМинус + Поз, 1);
			Если Символ = "p" Тогда
				НашлиP = Истина;
				ПозицияP = ПозицияМинус + Поз;
				Прервать;
			КонецЕсли; 	
			
			Если Символ = ";" Или Символ = "'" Или Символ = """" Тогда
				Прервать;
			КонецЕсли; 	
			
		КонецЦикла;	
		
		Если НашлиP Тогда
			
			ТекстПисьмаДляПравки = Лев(ТекстПисьмаДляПравки, ПозицияМинус - 1)
				+ "0"
				+ Сред(ТекстПисьмаДляПравки, ПозицияP);
				
			ТекстПисьмаДляПравкиНРег = НРег(ТекстПисьмаДляПравки);
		
		КонецЕсли;
		
		НачальнаяПозиция = ПозицияМинус + 1;
		Продолжить;
			
	КонецЦикла;
	
	ТекстПисьма = ТекстПисьмаДляПравки;
	
КонецПроцедуры	

Процедура ВставитьШапкуПисьмаВТекстHTML(ТекстHTML, ШапкаИнфо)
		
	НРегТекстHTML = НРег(ТекстHTML);
	
	// Нахождение места для вставки текста шапки
	ВставитьПеред = 1;
	ПозицияHTML = СтрНайти(НРегТекстHTML, "<html");
	Если ПозицияHTML > 0 Тогда
		ПозицияBody = СтрНайти(НРегТекстHTML, "<body",, ПозицияHTML);
		Если ПозицияBody > 0 Тогда
			ПозицияЗакрывающейсяСкобки = СтрНайти(НРегТекстHTML, ">",, ПозицияBody);
			Если ПозицияЗакрывающейсяСкобки > 0 Тогда
				ВставитьПеред = ПозицияЗакрывающейсяСкобки + 1;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	// Формирование текста шапки письма
	ШапкаHTML =
		"<div style='font-family:Arial;font-size:14px; width=90%;'>
		|<b>[Тема]</b>
		|</div>
		|<div style='font-family:Arial;font-size:12px; width=90%;'>
		|[От]<br/>
		|<b>[НадписьКому]</b> [Кому]<br/>
		|<b>[НадписьКопия]</b> [Копия]<br/>
		|<b>[НадписьСкрытая]</b>[Скрытая]<br/>
		|<b>[НадписьДата]</b> [Дата]<br/>
		|</div>
		|<hr>";

	ТекстHTMLДляТемы = РаботаСHTMLКлиентСервер.ЗаменитьСпецСимволыHTML(ШапкаИнфо.Тема);
	ШапкаHTML = СтрЗаменить(ШапкаHTML, "[Тема]", ТекстHTMLДляТемы);

	Если ТипЗнч(ШапкаИнфо.Ссылка) = Тип("ДокументСсылка.ВходящееПисьмо") Тогда
		ШапкаHTML = СтрЗаменить(ШапкаHTML, "[От]", 
			РаботаСHTMLКлиентСервер.ЗаменитьСпецСимволыHTML(Строка(ШапкаИнфо.Адресат)));
	Иначе
		СтрокаУчетнаяЗапись = Строка(ШапкаИнфо.УчетнаяЗапись);
		ШапкаHTML = СтрЗаменить(ШапкаHTML, "[От]", 
			РаботаСHTMLКлиентСервер.ЗаменитьСпецСимволыHTML(СтрокаУчетнаяЗапись));
	КонецЕсли;

	Если ЗначениеЗаполнено(ШапкаИнфо.Получатели) Тогда
		ШапкаHTML = СтрЗаменить(ШапкаHTML, "[НадписьКому]", НСтр("en='TO:';ru='Кому:';vi='Người nhận:'")); 
		ШапкаHTML = СтрЗаменить(ШапкаHTML, "[Кому]", 
			РаботаСHTMLКлиентСервер.ЗаменитьСпецСимволыHTML(ШапкаИнфо.Получатели)); 
	Иначе
		ШапкаHTML = СтрЗаменить(ШапкаHTML, "<b>[НадписьКому]</b> [Кому]<br/>", ""); 
	КонецЕсли;

	Если ЗначениеЗаполнено(ШапкаИнфо.Копии) Тогда
		ШапкаHTML = СтрЗаменить(ШапкаHTML, "[НадписьКопия]", НСтр("en='CC:';ru='Копия:';vi='CC:'")); 
		ШапкаHTML = СтрЗаменить(ШапкаHTML, "[Копия]", 
			РаботаСHTMLКлиентСервер.ЗаменитьСпецСимволыHTML(ШапкаИнфо.Копии));
	Иначе
		ШапкаHTML = СтрЗаменить(ШапкаHTML, "<b>[НадписьКопия]</b> [Копия]<br/>", ""); 
	КонецЕсли;
	
	Если ТипЗнч(ШапкаИнфо.Ссылка) = Тип("ДокументСсылка.ВходящееПисьмо") Тогда
		ШапкаHTML = СтрЗаменить(ШапкаHTML, "<b>[НадписьСкрытая]</b>[Скрытая]<br/>", ""); 
	Иначе
		Если ЗначениеЗаполнено(ШапкаИнфо.Скрытые) Тогда
			ШапкаHTML = СтрЗаменить(ШапкаHTML, "[НадписьСкрытая]", НСтр("en='BCC:';ru='Скрытая:';vi='BCC:'")); 
			ШапкаHTML = СтрЗаменить(ШапкаHTML, "[Скрытая]", 
				РаботаСHTMLКлиентСервер.ЗаменитьСпецСимволыHTML(ШапкаИнфо.Скрытые));
		Иначе
			ШапкаHTML = СтрЗаменить(ШапкаHTML, "<b>[НадписьСкрытая]</b>[Скрытая]<br/>", ""); 
		КонецЕсли;
	КонецЕсли;

	Если ПустаяСтрока(ШапкаИнфо.Дата) Тогда
		ШапкаHTML = СтрЗаменить(ШапкаHTML, Символы.ПС + "<b>[НадписьДата]:</b> [Дата]<br>", "");
	КонецЕсли;
	ШапкаHTML = СтрЗаменить(ШапкаHTML, "[НадписьДата]", НСтр("en='Date:';ru='Дата:';vi='Ngày:'"));
	ШапкаHTML = СтрЗаменить(ШапкаHTML, "[Дата]", РаботаСHTMLКлиентСервер.ЗаменитьСпецСимволыHTML(ШапкаИнфо.Дата));

	// Нахождение места для вставки конца div
	ВставитьDIVПеред = 1;
	ВставитьDIVПеред = СтрНайти(НРегТекстHTML, "</body");

	ТекстHTML = Лев(ТекстHTML, ВставитьПеред - 1) + ШапкаHTML + Сред(ТекстHTML, ВставитьПеред);

КонецПроцедуры

// В случае отсутствия у текста HTML тэгов <html></html>,  <body></body> добавляет их.
// Модифицирует параметр ТекстHTML
//
Процедура ДобавитьНеобходимыеТэгиHTML(ТекстHTML) Экспорт
	
	НРегТекстHTML = НРег(ТекстHTML);
	ПозицияТэгаHTML = СтрНайти(НРегТекстHTML, "<html");
	ПозицияТэгаBODY = СтрНайти(НРегТекстHTML, "<body");
	Если ПозицияТэгаHTML = 0 И ПозицияТэгаBODY = 0 Тогда
		ТекстHTML = "<html><body style=""margin-top:1px; padding-top:1px"">" + ТекстHTML + "</body></html>";
	ИначеЕсли ПозицияТэгаHTML = 0 И ПозицияТэгаBODY > 0 Тогда
		ТекстHTML = "<html>" + ТекстHTML + "</html>";
	ИначеЕсли ПозицияТэгаHTML > 0 И ПозицияТэгаBODY = 0 Тогда
		ПозицияОкончанияТэгаHTML = СтроковыеФункцииКлиентСервер.НайтиПосле(НРегТекстHTML, ">", ПозицияТэгаHTML);
		Голова = Лев(ТекстHTML, ПозицияОкончанияТэгаHTML);
		ПозицияЗакрывающегосяТэгаHTML = СтрНайти(НРегТекстHTML, "</html>");
		Хвост = Сред(ТекстHTML, ПозицияЗакрывающегосяТэгаHTML);
		Середина = Сред(ТекстHTML, ПозицияОкончанияТэгаHTML + 1, ПозицияЗакрывающегосяТэгаHTML - ПозицияОкончанияТэгаHTML - 1);
		ТекстHTML = Голова + "<body style=""margin-top:1px; padding-top:1px"">" + Середина + "</body>" + Хвост;
	КонецЕсли;
	
КонецПроцедуры

// Удаляет теги из тела письма
Процедура УдалитьТеги(ТекстПисьмаHTML, ИмяТега) Экспорт
	
	НРегТекстHTML = НРег(ТекстПисьмаHTML);
	
	Пока СтрНайти(НРегТекстHTML, "<" + ИмяТега) <> 0 Цикл
		
		ПозицияНачалаТегаHTML = СтрНайти(НРегТекстHTML, "<" + ИмяТега);
		ПозицияОкончанияТегаHTML = 0;
		Если ПозицияНачалаТегаHTML > 0 Тогда
			ПозицияОкончанияТегаHTML = СтроковыеФункцииКлиентСервер.НайтиПосле(НРегТекстHTML, ">", ПозицияНачалаТегаHTML);
		КонецЕсли;
		
		Если ПозицияНачалаТегаHTML <> 0 И ПозицияОкончанияТегаHTML <> 0 Тогда
			
			ПозицияНачалаЗакрывающегоТегаHTML = СтроковыеФункцииКлиентСервер.НайтиПосле(НРегТекстHTML, "</" + ИмяТега, ПозицияОкончанияТегаHTML);
			ПозицияОкончанияЗакрывающегоТегаHTML = 0;
			Если ПозицияНачалаЗакрывающегоТегаHTML > 0 Тогда
				ПозицияОкончанияЗакрывающегоТегаHTML = СтроковыеФункцииКлиентСервер.НайтиПосле(НРегТекстHTML, ">", ПозицияНачалаЗакрывающегоТегаHTML);
			КонецЕсли;
			
			Если ПозицияНачалаЗакрывающегоТегаHTML <> 0 И ПозицияОкончанияЗакрывающегоТегаHTML <> 0 Тогда
				
				ТекстПисьмаHTML = Лев(ТекстПисьмаHTML, ПозицияНачалаТегаHTML - 1) 
					+ Сред(ТекстПисьмаHTML, ПозицияОкончанияЗакрывающегоТегаHTML + 1);
				НРегТекстHTML = НРег(ТекстПисьмаHTML);
				
			Иначе
				Возврат;	
			КонецЕсли;		
				
		Иначе
			
			Возврат;	
			
		КонецЕсли;		
		
	КонецЦикла;	
	
КонецПроцедуры

// Удаляет onmouseover onmouseout из тега A
//
// Параметры:
//  ТекстПисьмаHTML - Строка с html текстом письма
//  ИмяСвойства - Строка, например "onmouseover"
//
Процедура УдалитьСвойствоТегаА(ТекстПисьмаHTML, ИмяСвойства) Экспорт
	
	УдалитьСвойствоТегаАСУказаниемКавычки(ТекстПисьмаHTML, ИмяСвойства, """");
	УдалитьСвойствоТегаАСУказаниемКавычки(ТекстПисьмаHTML, ИмяСвойства, "'");
	
КонецПроцедуры

// Удаляет onmouseover onmouseout из тега A
//
// Параметры:
//  ТекстПисьмаHTML - Строка с html текстом письма
//  ИмяСвойства - Строка, например "onmouseover"
//  Кавычка - Строка   " или '
//
Процедура УдалитьСвойствоТегаАСУказаниемКавычки(ТекстПисьмаHTML, ИмяСвойства, Кавычка) Экспорт
	
	НРегТекстHTML = НРег(ТекстПисьмаHTML);
	
	ИмяСвойстваСКавычкой = ИмяСвойства + "=" + Кавычка;
	ЧислоВхождений = 0;
	
	Пока Найти(НРегТекстHTML, ИмяСвойстваСКавычкой) <> 0 Цикл
		
		ПозицияНачалаСвойства = Найти(НРегТекстHTML, ИмяСвойстваСКавычкой);
		ЧислоВхождений = ЧислоВхождений + 1;
		Если ЧислоВхождений > 1000 Тогда
			Возврат; // чтобы не было зацикливания
		КонецЕсли;	
		
		Если ПозицияНачалаСвойства <> 0 Тогда
			
			СвойствоВнутриТегаА = Ложь;
		
			Позиция = 0;
			Для Позиция = 0 По 100 Цикл
				
				Если ПозицияНачалаСвойства - Позиция > 0 Тогда
					
					Фрагмент = Сред(НРегТекстHTML, ПозицияНачалаСвойства - Позиция, 2);
					Если Фрагмент = "<a" Тогда
						СвойствоВнутриТегаА = Истина;
						Прервать;
					КонецЕсли;		
					
				КонецЕсли;	
				
			КонецЦикла;	
			
			Если СвойствоВнутриТегаА Тогда
				
				ПозицияОкончанияСвойства = СтроковыеФункцииКлиентСервер.НайтиПосле(
					НРегТекстHTML, Кавычка, ПозицияНачалаСвойства + СтрДлина(ИмяСвойстваСКавычкой));
					
				Если ПозицияОкончанияСвойства <> 0 Тогда
						
					ТекстПисьмаHTML = Лев(ТекстПисьмаHTML, ПозицияНачалаСвойства - 1) 
						+ Сред(ТекстПисьмаHTML, ПозицияОкончанияСвойства + 1);
					НРегТекстHTML = НРег(ТекстПисьмаHTML);
					
				Иначе
					Возврат; // чтобы не было зацикливания
				КонецЕсли;
				
			Иначе
				Возврат; // чтобы не было зацикливания
			КонецЕсли;	
			
		КонецЕсли;	
		
	КонецЦикла;	
	
КонецПроцедуры	

Процедура Удалить_position_absolute(ТекстHTML) Экспорт
	
	ТекстHTML = СтрЗаменить(ТекстHTML, "position: absolute;", "");
	ТекстHTML = СтрЗаменить(ТекстHTML, "position: absolute", "");	
	
	ТекстHTML = СтрЗаменить(ТекстHTML, "position:absolute;", "");
	ТекстHTML = СтрЗаменить(ТекстHTML, "position:absolute", "");	
	
КонецПроцедуры	

// Проверяет, содержит ли ссылка схему
//
Функция СтрокаНачинаетсяСПодстроки(Строка, Подстрока)

	Возврат (Найти(НРег(СокрЛ(Строка)), НРег(Подстрока)) = 1);

КонецФункции

Процедура ЗаменитьСпецСимволHTML(Строка, КодСимвола, ИмяСимвола)

	Строка = СтрЗаменить(Строка, Символ(КодСимвола), "&" + ИмяСимвола + ";");

КонецПроцедуры

Процедура ЗаменитьСпецСимволHTMLОбратно(Строка, КодСимвола, ИмяСимвола)

	Строка = СтрЗаменить(Строка, "&" + ИмяСимвола + ";", Символ(КодСимвола));

КонецПроцедуры

// Добавляет тег в конкретную позицию. Меняет значение Строка и Смещение.
//
Процедура ДобавитьТегСсылки(
	Строка,
	НачальнаяПозиция,
	КонечнаяПозиция,
	Схема,
	НовоеЗначениеСхемы,
	Смещение,
	ОбрезатьГраничныеСимволыСсылки = Ложь,
	СимволПередСсылкой = "",
	СимволКонцаСсылки = "") 

	НачалоСтроки = Лев(Строка, Смещение + НачальнаяПозиция - 1);

	ЕстьИмяСсылка = Ложь;
	Если СтрЗаканчиваетсяНа(НачалоСтроки, "Ссылка: ") Тогда
		НачалоСтроки = Лев(НачалоСтроки, СтрДлина(НачалоСтроки)-8);
		ЕстьИмяСсылка = Истина;
	КонецЕсли;

	// Обрезание граничных символов
	Если ОбрезатьГраничныеСимволыСсылки Тогда
		Ссылка = Сред(Строка,
			Смещение + НачальнаяПозиция + СтрДлина(СимволПередСсылкой),
			КонечнаяПозиция - НачальнаяПозиция - СтрДлина(СимволПередСсылкой) - СтрДлина(СимволКонцаСсылки));
	Иначе
		Ссылка = Сред(Строка, Смещение + НачальнаяПозиция, КонечнаяПозиция - НачальнаяПозиция);
	КонецЕсли;

	Если ЕстьИмяСсылка Тогда
		ПредставлениеСсылки = НСтр("en='Tap here';ru='Ссылка';vi='Tham chiếu'");
	Иначе
		ПредставлениеСсылки = Ссылка;
	КонецЕсли;
	КонецСтроки         = Прав(Строка, СтрДлина(Строка) - (Смещение + КонечнаяПозиция - 1));

	// Замены схемы в ссылке при необходимости, например "www." => "http://www."
	Если ЗначениеЗаполнено(НовоеЗначениеСхемы) Тогда

		ДлинаСхемы = СтрДлина(Схема);
		СхемаВСсылке = Лев(Ссылка, ДлинаСхемы);

		Если НРег(Схема) = НРег(СхемаВСсылке) Тогда
			Ссылка = НовоеЗначениеСхемы + Сред(Ссылка, ДлинаСхемы + 1);
		КонецЕсли;

	КонецЕсли;

	// Удаление тегов из ссылки
	ПозицияНачалаОткрывающегоТега = СтрНайти(Ссылка, "<");
	Пока ПозицияНачалаОткрывающегоТега <> 0 Цикл

		СтруктураТега = ПолучитьТегВТекстеHTML(Ссылка, , ПозицияНачалаОткрывающегоТега);
		Если ЗаполненаСтруктураТега(СтруктураТега) Тогда

			Ссылка = Лев(Ссылка, СтруктураТега.ПозицияНачалаОткрывающегоТега - 1) + Сред(Ссылка, СтруктураТега.ПозицияОкончанияОткрывающегоТега + 1);
			ПозицияНачалаОткрывающегоТега = ПозицияНачалаОткрывающегоТега - 1;

		КонецЕсли;

		ПозицияНачалаОткрывающегоТега = СтрНайти(Ссылка, "<",, ПозицияНачалаОткрывающегоТега);

	КонецЦикла;

	Если Не СтрНайти(Строка, """") Тогда
		СсылкаСТегом = "<a href=""" + Ссылка + """>" + ПредставлениеСсылки + "</a>";

	ИначеЕсли Не СтрНайти(Строка, "'") Тогда
		СсылкаСТегом = "<a href='" + Ссылка + "'>" + ПредставлениеСсылки + "</a>";

	Иначе
		РаботаСHTMLКлиентСервер.ЗаменитьСпецСимволыHTMLОбратно(Ссылка);
		РаботаСHTMLКлиентСервер.ЗаменитьСпецСимволыHTML(Ссылка);

		СсылкаСТегом = "<a href=""" + Ссылка + """>" + ПредставлениеСсылки + "</a>";

	КонецЕсли;

	Строка   = НачалоСтроки + СсылкаСТегом + КонецСтроки;
	Смещение = СтрДлина(НачалоСтроки + СсылкаСТегом) + 1;

КонецПроцедуры

// Добавляет теги ко всем ссылкам, находящимся в строке и соответствующим указанной схеме.
Процедура ДобавитьТегиКСсылкамСоСхемой(ТекстHTML,Схема, НовоеЗначениеСхемы = "")

	СхемаПоиска         = НРег(Схема);
	ТекстHTMLПоиска     = НРег(ТекстHTML);
	Длина               = СтрДлина(ТекстHTML);
	НоваяСтрока         = "";
	Смещение            = 0;
	КонецТега           = ">";
	ДлинаКонцаТега      = СтрДлина(КонецТега);
	ЯвляетсяТегомЯкоря  = Ложь;
	ЗакрывающийТегЯкоря = "</a>";
	НазваниеЭлементаСсылки     = "a";
	ДлинаЗакрывающегоТегаЯкоря = СтрДлина(ЗакрывающийТегЯкоря);

	НачалоСсылки        = СтрНайти(ТекстHTMLПоиска, СхемаПоиска);
	СписокОграничителейURI = РаботаСHTMLВызовСервераПовтИсп.СписокОграничителейURI();

	Пока НачалоСсылки <> 0 Цикл

		// Проверять что позиция не в параметрах какого-либо тега
		Если ПозицияНаходитсяВПараметреТега(ТекстHTMLПоиска, НачалоСсылки, НазваниеЭлементаСсылки, ЯвляетсяТегомЯкоря) Тогда

			ПозицияОкончанияОткрывающегоТега = 0;

			Если ЯвляетсяТегомЯкоря Тогда

				// Если тег является якорем - ищем 
				ПозицияОкончанияОткрывающегоТега = СтрНайти(ТекстHTMLПоиска, ЗакрывающийТегЯкоря,, НачалоСсылки);
				ПозицияОкончанияОткрывающегоТега = ПозицияОкончанияОткрывающегоТега + ДлинаЗакрывающегоТегаЯкоря;
				ДлинаСмещения = ДлинаЗакрывающегоТегаЯкоря;

			КонецЕсли;

			Если ПозицияОкончанияОткрывающегоТега = 0 Тогда

				ПозицияОкончанияОткрывающегоТега = СтрНайти(ТекстHTMLПоиска, КонецТега,, НачалоСсылки);

				Если ПозицияОкончанияОткрывающегоТега = 0 Тогда

					// Если нет окончания тега - не выделяем больше ссылок
					Прервать;

				КонецЕсли;

				ПозицияОкончанияОткрывающегоТега = ПозицияОкончанияОткрывающегоТега + ДлинаКонцаТега;
				ДлинаСмещения = ДлинаКонцаТега;

			КонецЕсли;

			// Если есть окончание тега - выделяем ссылки после тега
			Смещение        = Смещение + (ПозицияОкончанияОткрывающегоТега - 1);
			ТекстHTMLПоиска = Сред(ТекстHTMLПоиска, ПозицияОкончанияОткрывающегоТега);
			НачалоСсылки    = СтрНайти(ТекстHTMLПоиска, СхемаПоиска);

			Продолжить;

		КонецЕсли;

		Если ПозицияНаходитсяВТеге(ТекстHTMLПоиска, НазваниеЭлементаСсылки, НачалоСсылки) Тогда

			ПозицияЗакрывающегоТегаЯкоря = СтрНайти(ТекстHTMLПоиска, ЗакрывающийТегЯкоря,, НачалоСсылки);

			Если ПозицияЗакрывающегоТегаЯкоря = 0 Тогда

				// Если нет закрывающего "якорь" тега - не выделяем больше ссылок
				Прервать;

			КонецЕсли;

			ПозицияЗакрывающегоТегаЯкоря = ПозицияЗакрывающегоТегаЯкоря + ДлинаЗакрывающегоТегаЯкоря;

			// Если есть закрывающий "якорь" тег - выделяем ссылки после закрывающего тега
			Смещение        = Смещение + (ПозицияЗакрывающегоТегаЯкоря - 1);
			ТекстHTMLПоиска = Сред(ТекстHTMLПоиска, ПозицияЗакрывающегоТегаЯкоря);
			НачалоСсылки    = СтрНайти(ТекстHTMLПоиска, СхемаПоиска);

			Продолжить;

		КонецЕсли;

		Если НачалоСсылки = 1 Тогда
			СимволПередСсылкой = "";

		Иначе

			СимволПередСсылкой = Сред(ТекстHTMLПоиска, НачалоСсылки - 1, 1);

			Если СимволПередСсылкой = ";" Тогда

				ЗакодированныеКавычки = "&quot;";
				ДлинаКавычек          = СтрДлина(ЗакодированныеКавычки);

				Если НачалоСсылки - ДлинаКавычек > 0 Тогда
					ВозможныеКавычки = Сред(ТекстHTMLПоиска, НачалоСсылки - ДлинаКавычек, ДлинаКавычек);

					Если ВозможныеКавычки = ЗакодированныеКавычки Тогда
						СимволПередСсылкой = ЗакодированныеКавычки;
					КонецЕсли;

				КонецЕсли;

			КонецЕсли;

			Если СписокОграничителейURI.НайтиПоЗначению(СимволПередСсылкой) <> Неопределено Тогда
				СимволПередСсылкой = "";

			ИначеЕсли СимволПередСсылкой = ">" Тогда
				СимволПередСсылкой = ""; // Тег перед ссылкой

			КонецЕсли;

		КонецЕсли;

		Если ПустаяСтрока(СимволПередСсылкой) Тогда

			КонецСсылки = НайтиКонецСсылки(ТекстHTMLПоиска, НачалоСсылки + СтрДлина(СхемаПоиска), СписокОграничителейURI);

			// Добавляем теги к оригинальному тексту, т.к. текст поиска в нижнем регистре
			ДобавитьТегСсылки(
				ТекстHTML,
				НачалоСсылки,
				КонецСсылки,
				Схема,
				НовоеЗначениеСхемы,
				Смещение);

			ТекстHTMLПоиска = Сред(ТекстHTMLПоиска, КонецСсылки + 1);
			НачалоСсылки    = СтрНайти(ТекстHTMLПоиска, СхемаПоиска);

			Продолжить;

		ИначеЕсли СимволПередСсылкой = """" Или СимволПередСсылкой = "&quot;" Тогда

			СимволКонцаСсылки = """";
			КонецСсылки       = НайтиКонецСсылки(ТекстHTMLПоиска, НачалоСсылки + СтрДлина(СхемаПоиска), СписокОграничителейURI, Истина, СимволКонцаСсылки);

			// Добавляем теги к оригинальному тексту, т.к. текст поиска в нижнем регистре
			ДобавитьТегСсылки(
				ТекстHTML,
				НачалоСсылки - СтрДлина(СимволПередСсылкой), // Включаем открывающие кавычки в ссылку
				КонецСсылки,
				Схема,
				НовоеЗначениеСхемы,
				Смещение,
				Истина,
				СимволПередСсылкой,
				СимволКонцаСсылки);

			ТекстHTMLПоиска = Сред(ТекстHTMLПоиска, КонецСсылки + 1);
			НачалоСсылки    = СтрНайти(ТекстHTMLПоиска, СхемаПоиска);

			Продолжить;

		КонецЕсли;

		Смещение        = Смещение + НачалоСсылки;
		ТекстHTMLПоиска = Сред(ТекстHTMLПоиска, НачалоСсылки + 1);
		НачалоСсылки    = СтрНайти(ТекстHTMLПоиска, СхемаПоиска);

	КонецЦикла;

КонецПроцедуры

// Возвращает позицию конца ссылки в строке - первый незначащий символ
Функция НайтиКонецСсылки(ТекстHTML, НачальнаяПозиция, СписокНезначащихСимволов,
	РазрешитьПробелВСсылке = Ложь, СимволКонцаСсылки = Неопределено)

	Списки = РаботаСHTMLВызовСервераПовтИсп.ПолучитьСпискиСимволов();

	НайденНезначащийСимвол           = Ложь;
	ОбрабатываемаяСтрока             = Сред(ТекстHTML, НачальнаяПозиция);
	ПоложениеПервогоНезначащегоСимвола = 0;

	Пока Не НайденНезначащийСимвол Цикл

		ПервыйСимвол = Лев(ОбрабатываемаяСтрока, 1);

		Если ЗначениеЗаполнено(СимволКонцаСсылки) И ПервыйСимвол = СимволКонцаСсылки Тогда

			НайденНезначащийСимвол             = Истина;
			ПоложениеПервогоНезначащегоСимвола = ПоложениеПервогоНезначащегоСимвола + 1;

			Прервать;

		ИначеЕсли ЗначениеЗаполнено(СимволКонцаСсылки) И ПервыйСимвол = "&" Тогда

			ВозможныйСпецСимвол = ПолучитьВозможныйСпецСимвол(ОбрабатываемаяСтрока);
			СпецСимвол          = Списки.ОбратноеСоответствиеСпецСимволов.Получить(ВозможныйСпецСимвол);

			Если СпецСимвол <> Неопределено И Символ(СпецСимвол) = СимволКонцаСсылки Тогда

				НайденНезначащийСимвол = Истина;
				СимволКонцаСсылки      = "&" + ВозможныйСпецСимвол + ";";
				ПоложениеПервогоНезначащегоСимвола = ПоложениеПервогоНезначащегоСимвола + СтрДлина(СимволКонцаСсылки);

				Прервать;

			КонецЕсли;

		КонецЕсли;

		Если ПервыйСимвол = "&" Тогда

			ВозможныйСпецСимвол        = ПолучитьВозможныйСпецСимвол(ОбрабатываемаяСтрока);
			ДлинаВозможногоСпецСимвола = СтрДлина(ВозможныйСпецСимвол);

			Если Списки.ЗначимыеВURIСпецСимволы.НайтиПоЗначению(ВозможныйСпецСимвол) <> Неопределено Тогда

				ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, ДлинаВозможногоСпецСимвола + 3);
				ПоложениеПервогоНезначащегоСимвола = ПоложениеПервогоНезначащегоСимвола + ДлинаВозможногоСпецСимвола + 2;

				Продолжить;

			ИначеЕсли Списки.ДопустимыеВURIСпецСимволы.НайтиПоЗначению(ВозможныйСпецСимвол) <> Неопределено Тогда

				ЕстьЗначимыйСимволДоКонцаСсылки = ЕстьЗначимыйСимволДоКонцаСсылки(
					ОбрабатываемаяСтрока,
					СписокНезначащихСимволов,
					РазрешитьПробелВСсылке,
					ДлинаВозможногоСпецСимвола + 2);

				Если ЕстьЗначимыйСимволДоКонцаСсылки Тогда

					ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, ДлинаВозможногоСпецСимвола + 3);
					ПоложениеПервогоНезначащегоСимвола = ПоложениеПервогоНезначащегоСимвола + ДлинаВозможногоСпецСимвола + 2;

					Продолжить;

				Иначе
					ПервыйСимвол = "";

				КонецЕсли;

			ИначеЕсли Списки.ОбратноеСоответствиеСпецСимволов.Получить(ВозможныйСпецСимвол) <> Неопределено Тогда
				ПервыйСимвол = "";

			КонецЕсли;

		КонецЕсли;

		Если ПервыйСимвол = "<" Тогда

			СтруктураТега = ПолучитьТегВТекстеHTML(ОбрабатываемаяСтрока);
			Если ЗаполненаСтруктураТега(СтруктураТега) Тогда

				Если СтруктураТега.ПозицияНачалаОткрывающегоТега = 1 Тогда

					Если ТегСодержитсяВСписке(СтруктураТега, Списки.СписокДопустимыхВСсылкеТегов) Тогда

						ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, 
							СтруктураТега.ПозицияОкончанияОткрывающегоТега + 1);

						ПоложениеПервогоНезначащегоСимвола = 
							ПоложениеПервогоНезначащегоСимвола + СтруктураТега.ПозицияОкончанияОткрывающегоТега;

						Продолжить;

					Иначе
						ПервыйСимвол = "";

					КонецЕсли;

				Иначе
					ПервыйСимвол = "";

				КонецЕсли;

			Иначе
				ПервыйСимвол = "";

			КонецЕсли;

		КонецЕсли;

		Если СписокНезначащихСимволов.НайтиПоЗначению(ПервыйСимвол) <> Неопределено 
			И Не ЕстьЗначимыйСимволДоКонцаСсылки(ОбрабатываемаяСтрока, СписокНезначащихСимволов, РазрешитьПробелВСсылке) Тогда
			ПервыйСимвол = "";

		КонецЕсли;
		
		Если ПервыйСимвол = " " И РазрешитьПробелВСсылке Тогда

			ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, 2);
			ПоложениеПервогоНезначащегоСимвола = ПоложениеПервогоНезначащегоСимвола + 1;

			Продолжить;

		КонецЕсли;

		Если ПустаяСтрока(ПервыйСимвол) Тогда

			НайденНезначащийСимвол = Истина;

			Прервать;

		КонецЕсли;

		ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, 2);
		ПоложениеПервогоНезначащегоСимвола = ПоложениеПервогоНезначащегоСимвола + 1;

	КонецЦикла;

	// Если не был найден не значащий символ - все равно возвращаем - позиция конца строки.
	Возврат НачальнаяПозиция + ПоложениеПервогоНезначащегоСимвола;

КонецФункции

// Проверяет наличие значащего символа до конца ссылки. 
// Концом ссылки считаются стандартные незначащие символы.
Функция ЕстьЗначимыйСимволДоКонцаСсылки(Строка, СписокНезначащихСимволов,
	РазрешитьПробелВСсылке = Ложь, НачальнаяПозиция = 0)

	ОбратноеСоответствиеСпецСимволов = РаботаСHTMLВызовСервераПовтИсп.ПолучитьОбратноеСоответствиеСпецСимволов();
	ДопустимыеВURIСпецСимволы        = РаботаСHTMLВызовСервераПовтИсп.ДопустимыеВURIСпецСимволы();
	ЗначимыеВURIСпецСимволы          = РаботаСHTMLВызовСервераПовтИсп.ЗначимыеВURIСпецСимволы();
	СписокДопустимыхВСсылкеТегов     = РаботаСHTMLВызовСервераПовтИсп.СписокДопустимыхВСсылкеТегов();

	ОбрабатываемаяСтрока = Сред(Строка, НачальнаяПозиция + 1);
	НайденЗначащийСимвол = Ложь;

	Пока Не НайденЗначащийСимвол Цикл

		ПервыйСимвол = Лев(ОбрабатываемаяСтрока, 1);

		Если ПервыйСимвол = " " И РазрешитьПробелВСсылке Тогда
			ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, 2);

		ИначеЕсли ПустаяСтрока(ПервыйСимвол) Тогда
			Прервать;

		ИначеЕсли ПервыйСимвол = "&" Тогда

			ВозможныйСпецСимвол = ПолучитьВозможныйСпецСимвол(ОбрабатываемаяСтрока);
			ДлинаВозможногоСпецСимвола = СтрДлина(ВозможныйСпецСимвол);

			Если ЗначимыеВURIСпецСимволы.НайтиПоЗначению(ВозможныйСпецСимвол) <> Неопределено Тогда
				НайденЗначащийСимвол = Истина;

			ИначеЕсли ДопустимыеВURIСпецСимволы.НайтиПоЗначению(ВозможныйСпецСимвол) <> Неопределено
				Или ОбратноеСоответствиеСпецСимволов.Получить(ВозможныйСпецСимвол) <> Неопределено Тогда

				ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, ДлинаВозможногоСпецСимвола + 3);

			Иначе

				НайденЗначащийСимвол = Истина;

			КонецЕсли;

		ИначеЕсли ПервыйСимвол = "<" Тогда

			СтруктураТега = ПолучитьТегВТекстеHTML(ОбрабатываемаяСтрока);
			Если ЗаполненаСтруктураТега(СтруктураТега) Тогда

				Если СтруктураТега.ПозицияНачалаОткрывающегоТега = 1 Тогда

					Если ТегСодержитсяВСписке(СтруктураТега, СписокДопустимыхВСсылкеТегов) Тогда

						ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, СтруктураТега.ПозицияОкончанияОткрывающегоТега + 1);
						Продолжить;

					Иначе
						Прервать;
					КонецЕсли;

				Иначе
					Прервать;
				КонецЕсли;

			Иначе
				Прервать;
			КонецЕсли;

		ИначеЕсли СписокНезначащихСимволов.НайтиПоЗначению(ПервыйСимвол) <> Неопределено Тогда
			ОбрабатываемаяСтрока = Сред(ОбрабатываемаяСтрока, 2);

		Иначе
			НайденЗначащийСимвол = Истина;

		КонецЕсли;

	КонецЦикла;

	Возврат НайденЗначащийСимвол;

КонецФункции

// Возвращает спецсимвол HTML (&СпецСимвол;), если он присутствует.
// Возвращает Неопределено, если нет возможных спецсимволов.
Функция ПолучитьВозможныйСпецСимвол(Строка, ПозицияСпецСимвола = 0)

	ОбрабатываемаяСтрока = Сред(Строка, ПозицияСпецСимвола + 1);
	ПервыйСимвол         = Лев(ОбрабатываемаяСтрока, 1);

	Если ПервыйСимвол = "&" Тогда

		КонецСпецСимвола = СтрНайти(ОбрабатываемаяСтрока, ";");

		Если КонецСпецСимвола <> 0 Тогда

			СпецСимвол = Сред(ОбрабатываемаяСтрока, 2, КонецСпецСимвола - 2);

			Возврат СпецСимвол;

		КонецЕсли;

	КонецЕсли;

	Возврат Неопределено;

КонецФункции

// Возвращает структуру первого тега данного элемента в тексте HTML.
// Если не указано название элемента то возвращает первый встреченный тег.
// Поиск тега ведется с переданной начальной позиции.
//
// 	Структура тега: 
//		НазваниеЭлемента - название элемента найденного тега;
//		ПараметрыОткрывающегоТега - строка, содержащая параметры открывающего тега;
//		Содержание - стока, содержащие данные, находящие между открывающим и закрывающим тегом;
//		ПозицияНачалаОткрывающегоТега - позиция символа "<" открывающего тега;
//		ПозицияОкончанияОткрывающегоТега - позиция символа ">" открывающего тега;
//		ПозицияНачалаЗакрывающегоТега - позиция символа "<" закрывающего тега;
//		ПозицияОкончанияЗакрывающегоТега - позиция символа ">" закрывающего тега;
//		ПозицияНачалаТега - позиция символа "<" открывающего тега;
//		ПозицияОкончанияТега - если есть закрывающий тег, то позиция символа ">" закрывающего тега;
//							   если нет закрывающего тега, то позиция символа ">" открывающего тега.
//
Функция ПолучитьТегВТекстеHTML(ТекстHTML, НазваниеЭлемента = "", НачальнаяПозиция = 1) Экспорт

	Если Не ЗначениеЗаполнено(НазваниеЭлемента) Тогда

		НачалоОткрывающегоТега  = "<";
		НазваниеТега            = "";
		ОбрабатываемыйТекстHTML = ТекстHTML;

		ПозицияНачалаОткрывающегоТега = СтрНайти(ОбрабатываемыйТекстHTML, НачалоОткрывающегоТега);
		Пока ПозицияНачалаОткрывающегоТега <> 0 Цикл

			ОбрабатываемыйТекстHTML  = Сред(ОбрабатываемыйТекстHTML, ПозицияНачалаОткрывающегоТега + 1);
			ПервыйСимволНазванияТега = Лев(ОбрабатываемыйТекстHTML, 1);

			Если ЗначениеЗаполнено(ПервыйСимволНазванияТега) Тогда
				ОчереднойСимволНазванияТега = ПервыйСимволНазванияТега;

				Пока ЗначениеЗаполнено(ОчереднойСимволНазванияТега)
					И ОчереднойСимволНазванияТега <> ">" Цикл

					НазваниеТега                = НазваниеТега + ОчереднойСимволНазванияТега;
					ОбрабатываемыйТекстHTML     = Сред(ОбрабатываемыйТекстHTML, 2);
					ОчереднойСимволНазванияТега = Лев(ОбрабатываемыйТекстHTML, 1);

				КонецЦикла;

				ПозицияНачалаОткрывающегоТега = 0;

			Иначе

				ПозицияНачалаОткрывающегоТега = СтрНайти(ОбрабатываемыйТекстHTML, НачалоОткрывающегоТега);

			КонецЕсли;

		КонецЦикла;

		Если ЗначениеЗаполнено(НазваниеТега) Тогда

			НазваниеЭлемента = НазваниеТега;

		КонецЕсли;

	КонецЕсли;

	ПараметрыОткрывающегоТега        = "";
	Содержание                       = "";
	ПозицияНачалаОткрывающегоТега    = 0;
	ПозицияОкончанияОткрывающегоТега = 0;
	ПозицияНачалаЗакрывающегоТега    = 0;
	ПозицияОкончанияЗакрывающегоТега = 0;
	ПозицияНачалаТега                = 0;
	ПозицияОкончанияТега             = 0;

	НачалоОткрывающегоТега  = "<" + НРег(НазваниеЭлемента);
	КонецОткрывающегоТега   = ">";
	ЗакрывающийТег          = "</" + НРег(НазваниеЭлемента) + ">";
	ОбрабатываемыйТекстHTML = Сред(НРег(ТекстHTML), НачальнаяПозиция);

	Смещение = НачальнаяПозиция - 1;

	ПозицияНачалаОткрывающегоТегаСПараметрами   = СтрНайти(ОбрабатываемыйТекстHTML, НачалоОткрывающегоТега + " ");
	ПозицияНачалаОткрывающегоТегаСПараметрамиПС = СтрНайти(ОбрабатываемыйТекстHTML, НачалоОткрывающегоТега + Символы.ПС);
	ПозицияНачалаОткрывающегоТегаБезПараметров  = СтрНайти(ОбрабатываемыйТекстHTML, НачалоОткрывающегоТега + КонецОткрывающегоТега);
	ПозицияНачалаОткрывающегоТегаСЗакрытием     = СтрНайти(ОбрабатываемыйТекстHTML, НачалоОткрывающегоТега + "/>");
	
	Если ПозицияНачалаОткрывающегоТегаСПараметрами <> 0 Тогда
		Если ПозицияНачалаОткрывающегоТега <> 0 Тогда
			ПозицияНачалаОткрывающегоТега = Мин(ПозицияНачалаОткрывающегоТега, ПозицияНачалаОткрывающегоТегаСПараметрами);
		Иначе
			ПозицияНачалаОткрывающегоТега = ПозицияНачалаОткрывающегоТегаСПараметрами;
		КонецЕсли;
	КонецЕсли;

	Если ПозицияНачалаОткрывающегоТегаСПараметрамиПС <> 0 Тогда
		Если ПозицияНачалаОткрывающегоТега <> 0 Тогда
			ПозицияНачалаОткрывающегоТега = Мин(ПозицияНачалаОткрывающегоТега, ПозицияНачалаОткрывающегоТегаСПараметрамиПС);
		Иначе
			ПозицияНачалаОткрывающегоТега = ПозицияНачалаОткрывающегоТегаСПараметрамиПС;
		КонецЕсли;
	КонецЕсли;

	Если ПозицияНачалаОткрывающегоТегаБезПараметров <> 0 Тогда
		Если ПозицияНачалаОткрывающегоТега <> 0 Тогда
			ПозицияНачалаОткрывающегоТега = Мин(ПозицияНачалаОткрывающегоТега, ПозицияНачалаОткрывающегоТегаБезПараметров);
		Иначе
			ПозицияНачалаОткрывающегоТега = ПозицияНачалаОткрывающегоТегаБезПараметров;
		КонецЕсли;
	КонецЕсли;

	Если ПозицияНачалаОткрывающегоТегаСЗакрытием <> 0 Тогда
		Если ПозицияНачалаОткрывающегоТега <> 0 Тогда
			ПозицияНачалаОткрывающегоТега = Мин(ПозицияНачалаОткрывающегоТега, ПозицияНачалаОткрывающегоТегаСЗакрытием);
		Иначе
			ПозицияНачалаОткрывающегоТега = ПозицияНачалаОткрывающегоТегаСЗакрытием;
		КонецЕсли;
	КонецЕсли;

	Если ПозицияНачалаОткрывающегоТега <> 0 Тогда

		ОбрабатываемыйТекстHTML = Сред(ОбрабатываемыйТекстHTML, ПозицияНачалаОткрывающегоТега + СтрДлина(НачалоОткрывающегоТега));
		Смещение = Смещение + ПозицияНачалаОткрывающегоТега + СтрДлина(НачалоОткрывающегоТега) - 1;

		ПозицияОкончанияОткрывающегоТега = СтрНайти(ОбрабатываемыйТекстHTML, КонецОткрывающегоТега);
		Если ПозицияОкончанияОткрывающегоТега <> 0 Тогда

			ПараметрыОткрывающегоТега = Сред(ТекстHTML, Смещение + 1, ПозицияОкончанияОткрывающегоТега - 1);
			ОбрабатываемыйТекстHTML   = Сред(ОбрабатываемыйТекстHTML, ПозицияОкончанияОткрывающегоТега + СтрДлина(КонецОткрывающегоТега));
			Смещение                  = Смещение + ПозицияОкончанияОткрывающегоТега + СтрДлина(КонецОткрывающегоТега) - 1;

		Иначе

			ПозицияНачалаОткрывающегоТега = 0;

		КонецЕсли;

		ПозицияНачалаЗакрывающегоТега = СтрНайти(ОбрабатываемыйТекстHTML, ЗакрывающийТег);
		Если ПозицияНачалаЗакрывающегоТега <> 0 Тогда
			Содержание = Сред(ТекстHTML, Смещение + 1, ПозицияНачалаЗакрывающегоТега - 1);

		КонецЕсли;

	КонецЕсли;

	Если ПозицияНачалаОткрывающегоТега <> 0 Тогда
		ПозицияНачалаОткрывающегоТега = ПозицияНачалаОткрывающегоТега + (НачальнаяПозиция - 1);
		ПозицияНачалаТега = ПозицияНачалаОткрывающегоТега;
	КонецЕсли;

	Если ПозицияОкончанияОткрывающегоТега <> 0 Тогда
		ПозицияОкончанияОткрывающегоТега = ПозицияОкончанияОткрывающегоТега + (СтрДлина(НачалоОткрывающегоТега) - 1) + ПозицияНачалаОткрывающегоТега;
	КонецЕсли;

	Если ПозицияНачалаЗакрывающегоТега <> 0 Тогда
		ПозицияНачалаЗакрывающегоТега = ПозицияНачалаЗакрывающегоТега + ПозицияОкончанияОткрывающегоТега;
		ПозицияОкончанияЗакрывающегоТега = ПозицияНачалаЗакрывающегоТега + (СтрДлина(ЗакрывающийТег) - 1);
	КонецЕсли;

	Если ПозицияОкончанияЗакрывающегоТега <> 0 Тогда
		ПозицияОкончанияТега = ПозицияОкончанияЗакрывающегоТега;
	ИначеЕсли ПозицияОкончанияОткрывающегоТега <> 0 Тогда
		ПозицияОкончанияТега = ПозицияОкончанияОткрывающегоТега;
	КонецЕсли;

	СтруктураТега = Новый Структура();
	СтруктураТега.Вставить("НазваниеЭлемента", НазваниеЭлемента);
	СтруктураТега.Вставить("ПараметрыОткрывающегоТега", ПараметрыОткрывающегоТега);
	СтруктураТега.Вставить("Содержание", Содержание);
	СтруктураТега.Вставить("ПозицияНачалаОткрывающегоТега", ПозицияНачалаОткрывающегоТега);
	СтруктураТега.Вставить("ПозицияОкончанияОткрывающегоТега", ПозицияОкончанияОткрывающегоТега);
	СтруктураТега.Вставить("ПозицияНачалаЗакрывающегоТега", ПозицияНачалаЗакрывающегоТега);
	СтруктураТега.Вставить("ПозицияОкончанияЗакрывающегоТега", ПозицияОкончанияЗакрывающегоТега);
	СтруктураТега.Вставить("ПозицияНачалаТега", ПозицияНачалаТега);
	СтруктураТега.Вставить("ПозицияОкончанияТега", ПозицияОкончанияТега);

	Возврат СтруктураТега;

КонецФункции

// Проверяет наличие название элемента тега в списке значений
Функция ТегСодержитсяВСписке(СтруктураТега, СписокЗначений)

	Если Не ЗаполненаСтруктураТега(СтруктураТега) Тогда
		Возврат Ложь;
	КонецЕсли;

	НазваниеЭлемента = НРег(СтруктураТега.НазваниеЭлемента);

	Для Каждого ЭлементСписка Из СписокЗначений Цикл

		ЗначениеЭлементаСписка = ЭлементСписка.Значение;
		Если ТипЗнч(ЗначениеЭлементаСписка) = Тип("Строка") Тогда

			ЗначениеЭлементаСписка = НРег(ЗначениеЭлементаСписка);
			ЗначениеЗакрывающегоЭлементаСписка = "/" + ЗначениеЭлементаСписка;

			Если НазваниеЭлемента = ЗначениеЭлементаСписка
				Или НазваниеЭлемента = ЗначениеЗакрывающегоЭлементаСписка Тогда

				Возврат Истина;

			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

	Возврат Ложь;

КонецФункции

// Проверяет заполненность структуры тега: 
// - наличие всех необходимых тегу свойств в структуре;
// - заполненность позиции начала и окончания тега.
Функция ЗаполненаСтруктураТега(СтруктураТега) Экспорт

	Если (Не СтруктураТега.Свойство("НазваниеЭлемента"))
		Или (Не СтруктураТега.Свойство("ПараметрыОткрывающегоТега"))
		Или (Не СтруктураТега.Свойство("Содержание"))
		Или (Не СтруктураТега.Свойство("ПозицияНачалаОткрывающегоТега"))
		Или (Не СтруктураТега.Свойство("ПозицияОкончанияОткрывающегоТега"))
		Или (Не СтруктураТега.Свойство("ПозицияНачалаЗакрывающегоТега"))
		Или (Не СтруктураТега.Свойство("ПозицияОкончанияЗакрывающегоТега"))
		Или (Не СтруктураТега.Свойство("ПозицияНачалаТега"))
		Или (Не СтруктураТега.Свойство("ПозицияОкончанияТега"))  Тогда

		Возврат Ложь;

	КонецЕсли;

	Если ЗначениеЗаполнено(СтруктураТега.ПозицияНачалаТега)
		И ЗначениеЗаполнено(СтруктураТега.ПозицияОкончанияТега) Тогда

		Возврат Истина;

	КонецЕсли;

	Возврат Ложь;

КонецФункции

// Проверяет нахождение внутри параметров открывающего тега (возможно, который не закрыт).
//
Функция ПозицияНаходитсяВПараметреТега(ТекстHTML, Позиция, НужныйТег = "", ЯвляетсяНужнымТегом = Ложь)

	НачалоТега = "<";
	КонецТега  = ">";
	ОткрытТег  = Ложь;

	ЯвляетсяНужнымТегом = Ложь;
	НачалоТекстаHTML    = Лев(НРег(ТекстHTML), Позиция - 1);

	НайденнаяПозицияНачалаОткрывающегоТега = 0;
	ПозицияНачалаОткрывающегоТега          = СтрНайти(НачалоТекстаHTML, НачалоТега);

	Пока ПозицияНачалаОткрывающегоТега <> 0 Цикл

		НачалоТекстаHTML         = Сред(НачалоТекстаHTML, ПозицияНачалаОткрывающегоТега + 1);
		ПервыйСимволНазванияТега = Сред(НачалоТекстаHTML, 1, 1);
		ПозицияНужногоТега       = СтрНайти(НачалоТекстаHTML, НужныйТег + " ");

		Если ПозицияНужногоТега = 0 Тогда
			ПозицияНужногоТега = СтрНайти(НачалоТекстаHTML, НужныйТег + ">");
		КонецЕсли;

		Если ЗначениеЗаполнено(ПервыйСимволНазванияТега) Тогда

			ПозицияОкончанияОткрывающегоТега = СтрНайти(НачалоТекстаHTML, КонецТега);
			Если ПозицияОкончанияОткрывающегоТега <> 0 Тогда
				НачалоТекстаHTML = Сред(НачалоТекстаHTML, ПозицияОкончанияОткрывающегоТега + 1);

			Иначе

				Если ПозицияНужногоТега = 1 Тогда
					ЯвляетсяНужнымТегом = Истина;
				КонецЕсли;

				ОткрытТег = Истина;

				Прервать;

			КонецЕсли;

		КонецЕсли;

		ПозицияНачалаОткрывающегоТега = СтрНайти(НачалоТекстаHTML, НачалоТега);

	КонецЦикла;

	Возврат ОткрытТег;

КонецФункции

// Дописывать значение из href в свойство title ссылок и картинок.
//
Процедура ЗаполнитьСвойствоTitleУСсылок(ТекстHTML)

	// Для отображения подсказки к относительным ссылкам используется упрощенный
	// метод определения относительной ссылки и работы с тегом BASE, для самых частотных случаев.
	// Ссылка считается относительной, если в нет не присутствует ":".
	// К представлению относительных ссылок дописывается текст тега Base.
	ТегBody   = ПолучитьТегВТекстеHTML(ТекстHTML, "body");
	ТегBase   = ПолучитьТегВТекстеHTML(ТекстHTML, "base");
	ТекстBase = ПолучитьЗначениеПараметраТега(ТегBase, "href");

	Если ТекстBase = Неопределено
		Или (ЗаполненаСтруктураТега(ТегBody) И ТегBase.ПозицияОкончанияТега > ТегBody.ПозицияНачалаТега) Тогда
		ТекстBase = "";
	КонецЕсли;

	Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a");

	Пока ЗаполненаСтруктураТега(Тег) <> 0 Цикл

		СимволОграниченияHref  = Неопределено;
		СимволОграниченияTitle = Неопределено;
		Смещение    = 0;
		НачалоTitle = 0;
		КонецTitle  = 0;
		ТекстHref   = ПолучитьЗначениеПараметраТега(Тег, "href", СимволОграниченияHref);

		// Считаем ссылку относительной, если в ней нет символа ":"
		Если ТекстBase <> "" И СтрНайти(ТекстHref, ":") = 0 Тогда

			Если (Не СтрНачинаетсяС(ТекстHref, "\") И Не СтрНачинаетсяС(ТекстHref, "/"))
				И (Не СтрЗаканчиваетсяНа(ТекстBase, "\") И Не СтрЗаканчиваетсяНа(ТекстBase, "/")) Тогда

				// Нет "/" в тексте ссылки и Base
				ТекстHref = "/" + ТекстHref;

			ИначеЕсли (СтрНачинаетсяС(ТекстHref, "\") Или СтрНачинаетсяС(ТекстHref, "/"))
				И (СтрЗаканчиваетсяНа(ТекстBase, "\") Или СтрЗаканчиваетсяНа(ТекстBase, "/")) Тогда

				// Есть "/" в тексте ссылки и Base
				ТекстHref = Сред(ТекстHref, 2);

			КонецЕсли;

			ТекстHref = ТекстBase + ТекстHref;

		КонецЕсли;

		Если ТекстHref = Неопределено Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияТега + 1);
			Продолжить;
		КонецЕсли;

		ТекстTitle = ПолучитьЗначениеПараметраТега(Тег, "title", СимволОграниченияTitle, НачалоTitle, КонецTitle);

		Если ТекстTitle = Неопределено Тогда

			ТекстTitle = СтрШаблон(
				"title=%1%2%1", СимволОграниченияHref, ТекстHref);
			Смещение = Смещение + СтрДлина(ТекстTitle) + 1;

			НовыйОткрывающийТег = СтрШаблон(
				"<%1%3 %2>", Тег.НазваниеЭлемента, ТекстTitle, Тег.ПараметрыОткрывающегоТега);

		ИначеЕсли СтрНайти(ТекстTitle, ТекстHref) = 0 Тогда

			ТекстДоTitle = Лев(Тег.ПараметрыОткрывающегоТега, НачалоTitle - 1);
			ТекстПослеTitle = Сред(Тег.ПараметрыОткрывающегоТега, КонецTitle + 1);

			Если СимволОграниченияTitle <> СимволОграниченияHref Тогда
				Если СимволОграниченияTitle = """" Тогда
					ТекстHref = СтрЗаменить(ТекстHref, """", "'");
				ИначеЕсли СимволОграниченияTitle = "'" Тогда
					ТекстHref = СтрЗаменить(ТекстHref, "'", """");
				КонецЕсли;
			КонецЕсли;

			Если СимволОграниченияTitle = "" Тогда
				ТекстTitle = СтрЗаменить(ТекстTitle, """", "'");
				ТекстHref  = СтрЗаменить(ТекстHref, """", "'");
				СимволОграниченияTitle = """";
			КонецЕсли;
			
			ТекстTitle = СтрШаблон(
				"title=%1%2%3%1", СимволОграниченияTitle, ТекстTitle, Символы.ПС + ТекстHref);

			Смещение  = Смещение + СтрДлина(ТекстHref) + 1;

			НовыйОткрывающийТег = СтрШаблон(
				"<%1%2%3%4>", Тег.НазваниеЭлемента, ТекстДоTitle, ТекстTitle, ТекстПослеTitle);

		Иначе

			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияТега + Смещение + 1);
			Продолжить;

		КонецЕсли;

		ТекстHTML =
			Лев(ТекстHTML, Тег.ПозицияНачалаОткрывающегоТега - 1)
			+ НовыйОткрывающийТег
			+ Сред(ТекстHTML, Тег.ПозицияОкончанияОткрывающегоТега + 1);

		Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "a", Тег.ПозицияОкончанияТега + Смещение + 1);

	КонецЦикла;

	Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "img");

	Пока ЗаполненаСтруктураТега(Тег) <> 0 Цикл

		СимволОграниченияHref  = Неопределено;
		СимволОграниченияTitle = Неопределено;
		Смещение         = 0;
		ВнешнийТегСсылки = Неопределено;
		НачалоTitle      = 0;
		КонецTitle       = 0;

		Если Не ПозицияНаходитсяВТеге(ТекстHTML, "a", Тег.ПозицияНачалаТега, ВнешнийТегСсылки) Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "img", Тег.ПозицияОкончанияТега + Смещение + 1);
			Продолжить;
		КонецЕсли;

		ТекстHref = ПолучитьЗначениеПараметраТега(ВнешнийТегСсылки, "href", СимволОграниченияHref);
		Если ТекстHref = Неопределено Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "img", Тег.ПозицияОкончанияТега + Смещение + 1);
			Продолжить;
		КонецЕсли;

		ТекстTitle = ПолучитьЗначениеПараметраТега(Тег, "title", СимволОграниченияTitle, НачалоTitle, КонецTitle);
		Если ТекстTitle = Неопределено Тогда

			ТекстTitle = СтрШаблон(
				"title=%1%2%1", СимволОграниченияHref, ТекстHref);

			Смещение   = Смещение + СтрДлина(ТекстTitle) + 1;

			НовыйОткрывающийТег = СтрШаблон(
				"<%1%3 %2>", Тег.НазваниеЭлемента, ТекстTitle, Тег.ПараметрыОткрывающегоТега);

		ИначеЕсли СтрНайти(ТекстTitle, ТекстHref) = 0 Тогда

			ТекстДоTitle    = Лев(Тег.ПараметрыОткрывающегоТега, НачалоTitle - 1);
			ТекстПослеTitle = Сред(Тег.ПараметрыОткрывающегоТега, КонецTitle + 1);

			Если СимволОграниченияTitle <> СимволОграниченияHref Тогда

				Если СимволОграниченияTitle = """" Тогда
					ТекстHref = СтрЗаменить(ТекстHref, """", "'");

				ИначеЕсли СимволОграниченияTitle = "'" Тогда
					ТекстHref = СтрЗаменить(ТекстHref, "'", """");

				ИначеЕсли СимволОграниченияTitle = "" Тогда

					ТекстTitle = СтрЗаменить(ТекстHref, """", "'");
					ТекстHref  = СтрЗаменить(ТекстHref, """", "'");
					СимволОграниченияTitle = """";

				КонецЕсли;

			КонецЕсли;

			ТекстTitle = СтрШаблон(
				"title=%1%2%3%1", СимволОграниченияTitle, ТекстTitle, Символы.ПС + ТекстHref);

			Смещение   = Смещение + СтрДлина(ТекстHref) + 1;

			НовыйОткрывающийТег = СтрШаблон(
				"<%1%2%3%4>", Тег.НазваниеЭлемента, ТекстДоTitle, ТекстTitle, ТекстПослеTitle);

		Иначе

			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "img", Тег.ПозицияОкончанияТега + Смещение + 1);
			Продолжить;

		КонецЕсли;

		ТекстHTML =
			Лев(ТекстHTML, Тег.ПозицияНачалаОткрывающегоТега - 1)
			+ НовыйОткрывающийТег
			+ Сред(ТекстHTML, Тег.ПозицияОкончанияОткрывающегоТега + 1);

		Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "img", Тег.ПозицияОкончанияТега + Смещение + 1);

	КонецЦикла;

	Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "area");

	Пока ЗаполненаСтруктураТега(Тег) <> 0 Цикл

		СимволОграниченияHref = Неопределено;
		СимволОграниченияTitle = Неопределено;
		Смещение    = 0;
		НачалоTitle = 0;
		КонецTitle  = 0;
		ТекстHref   = ПолучитьЗначениеПараметраТега(Тег, "href", СимволОграниченияHref);

		Если ТекстHref = Неопределено Тогда
			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "area", Тег.ПозицияОкончанияТега + 1);
			Продолжить;
		КонецЕсли;

		ТекстTitle = ПолучитьЗначениеПараметраТега(Тег, "title", СимволОграниченияTitle, НачалоTitle, КонецTitle);

		Если ТекстTitle = Неопределено Тогда

			ТекстTitle = СтрШаблон(
				"title=%1%2%1", СимволОграниченияHref, ТекстHref);

			Смещение   = Смещение + СтрДлина(ТекстTitle) + 1;

			НовыйОткрывающийТег = СтрШаблон(
				"<%1%3 %2>", Тег.НазваниеЭлемента, ТекстTitle, Тег.ПараметрыОткрывающегоТега);

		ИначеЕсли СтрНайти(ТекстTitle, ТекстHref) = 0 Тогда

			ТекстДоTitle    = Лев(Тег.ПараметрыОткрывающегоТега, НачалоTitle - 1);
			ТекстПослеTitle = Сред(Тег.ПараметрыОткрывающегоТега, КонецTitle + 1);

			Если СимволОграниченияTitle <> СимволОграниченияHref Тогда

				Если СимволОграниченияTitle = """" Тогда
					ТекстHref = СтрЗаменить(ТекстHref, """", "'");

				ИначеЕсли СимволОграниченияTitle = "'" Тогда
					ТекстHref = СтрЗаменить(ТекстHref, "'", """");

				ИначеЕсли СимволОграниченияTitle = "" Тогда

					ТекстTitle = СтрЗаменить(ТекстTitle, """", "'");
					ТекстHref  = СтрЗаменить(ТекстHref, """", "'");
					СимволОграниченияTitle = """";

				КонецЕсли;

			КонецЕсли;

			ТекстTitle = СтрШаблон(
				"title=%1%2%3%1", СимволОграниченияTitle, ТекстTitle, Символы.ПС + ТекстHref);

			Смещение = Смещение + СтрДлина(ТекстHref) + 1;

			НовыйОткрывающийТег = СтрШаблон(
				"<%1%2%3%4>", Тег.НазваниеЭлемента, ТекстДоTitle, ТекстTitle, ТекстПослеTitle);

		Иначе

			Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "area", Тег.ПозицияОкончанияТега + Смещение + 1);
			Продолжить;

		КонецЕсли;

		ТекстHTML =
			Лев(ТекстHTML, Тег.ПозицияНачалаОткрывающегоТега - 1)
			+ НовыйОткрывающийТег
			+ Сред(ТекстHTML, Тег.ПозицияОкончанияОткрывающегоТега + 1);

		Тег = ПолучитьТегВТекстеHTML(ТекстHTML, "area", Тег.ПозицияОкончанияТега + Смещение + 1);

	КонецЦикла;

КонецПроцедуры

// Возвращает значение свойства параметра тега
Функция ПолучитьЗначениеПараметраТега(Тег, Параметр,
	СимволОграничения = Неопределено, НачалоПараметра = Неопределено, КонецПараметра = Неопределено) Экспорт

	Если Не ЗаполненаСтруктураТега(Тег) Тогда
		Возврат Неопределено;
	КонецЕсли;

	ПараметрыДляПоиска = НРег(Тег.ПараметрыОткрывающегоТега);
	ПараметрДляПоиска  = НРег(Параметр);
	ПозицияПараметра   = СтрНайти(ПараметрыДляПоиска, ПараметрДляПоиска);

	Если ПозицияПараметра = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	НачалоПараметра = СтрНайти(ПараметрыДляПоиска, ПараметрДляПоиска + "=""");
	Если НачалоПараметра <> 0 Тогда
		СимволОграничения = """";
	Иначе
		НачалоПараметра = СтрНайти(ПараметрыДляПоиска, ПараметрДляПоиска + "='");
		Если НачалоПараметра <> 0 Тогда
			СимволОграничения = "'";
		Иначе
			НачалоПараметра = СтрНайти(ПараметрыДляПоиска, ПараметрДляПоиска + "=");
			Если НачалоПараметра <> 0 Тогда
				СимволОграничения = "";
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Если НачалоПараметра = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если СимволОграничения = "" Тогда

		ЗакрывающийСимволОграничения = " ";
		КонецПараметра = СтрНайти(ПараметрыДляПоиска, ЗакрывающийСимволОграничения,,
			НачалоПараметра + СтрДлина(ПараметрДляПоиска + "=" + СимволОграничения));

		Если КонецПараметра = 0 Тогда

			ЗакрывающийСимволОграничения = Символы.ПС;
			КонецПараметра = СтрНайти(ПараметрыДляПоиска, ЗакрывающийСимволОграничения,,
				НачалоПараметра + СтрДлина(ПараметрДляПоиска + "=" + СимволОграничения));

			Если КонецПараметра = 0 Тогда
				КонецПараметра = СтрДлина(ПараметрыДляПоиска) + 1;
			КонецЕсли;

		КонецЕсли;

	Иначе

		КонецПараметра = СтрНайти(ПараметрыДляПоиска, СимволОграничения,,
			НачалоПараметра + СтрДлина(ПараметрДляПоиска + "=" + СимволОграничения));

		Если КонецПараметра = 0 Тогда
			Возврат Неопределено;
		КонецЕсли;

	КонецЕсли;

	Если КонецПараметра = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	ЗначениеПараметраТега = Сред(Тег.ПараметрыОткрывающегоТега, НачалоПараметра + СтрДлина(Параметр + "=" + СимволОграничения),
		КонецПараметра - (НачалоПараметра + СтрДлина(Параметр + "=" + СимволОграничения)));

	Возврат ЗначениеПараметраТега;

КонецФункции

// Дописывает текст в начало тега head. Если тега head нет - то создает его в начале тега html.
// Если тега html нет - то создает его, помещая текст HTML в содержимое тега body.
//
// Параметры::
//  ТекстHTML - Обрабатываемый текст HTML, в который могут быть добавлены теги.
//  ДобавляемыйТекст - Текст, который будет добавлен в тег head.
//
Процедура ДобавитьВТегHead(ТекстHTML, ДобавляемыйТекст) Экспорт
	
	// Если тега head нет, то его следует создать
	ТегHead = ПолучитьТегВТекстеHTML(ТекстHTML, "head");
	Если Не ЗаполненаСтруктураТега(ТегHead) Тогда
		
		// Если тега html нет, то его следует создать
		ТегHTML = ПолучитьТегВТекстеHTML(ТекстHTML, "html");
		Если Не ЗаполненаСтруктураТега(ТегHTML) Тогда
			
			// Если тега body нет, то его следует создать
			ТегBody = ПолучитьТегВТекстеHTML(ТекстHTML, "body");
			Если Не ЗаполненаСтруктураТега(ТегBody) Тогда
				ТекстHTML = "<body>" + ТекстHTML + "</body>";
			КонецЕсли;
			
			ТекстHTML = "<html>" + ТекстHTML + "</html>";
			ТегHTML = ПолучитьТегВТекстеHTML(ТекстHTML, "html");
			
		КонецЕсли;
		
		ТекстHTML =
			Лев(ТекстHTML, ТегHTML.ПозицияОкончанияОткрывающегоТега)
			+ "<head></head>"
			+ Сред(ТекстHTML, ТегHTML.ПозицияОкончанияОткрывающегоТега + 1);
		ТегHead = ПолучитьТегВТекстеHTML(ТекстHTML, "head");
		
	КонецЕсли;
	
	ТекстHTML = Лев(ТекстHTML, ТегHead.ПозицияОкончанияОткрывающегоТега)
		+ ДобавляемыйТекст
		+ Сред(ТекстHTML, ТегHead.ПозицияОкончанияОткрывающегоТега + 1);
	
КонецПроцедуры

// Переносит содержимое <style> и <base> в теге <head> из исходного текста.
// При этом игнорируется стиль v8doc-style и <base> самой ИБ.
//
// Параметры:
//  ТекстHTML - Строка - Текст, в который следует перенести теги.
//  ИсходныйТекстHTML - Строка - Текст, из которого следует взять теги.
//  ИскатьТегHeadВИсходномТексте - Булево - Флаг, определяющий необходимость искать
//                                 тег head в переданном тексте.
//
Процедура ПеренестиHead(ТекстHTML, ИсходныйТекстHTML, ИскатьТегHeadВИсходномТексте) Экспорт
	
	Если ИскатьТегHeadВИсходномТексте Тогда
		// Формируем текст head для переноса
		ТегHead = ПолучитьТегВТекстеHTML(ИсходныйТекстHTML, "head");
		Если Не ЗаполненаСтруктураТега(ТегHead) Тогда
			// Нет тега head - невозможно перенести style и base
			Возврат;
		КонецЕсли;
		ОбрабатываемыйТекстHTML = ТегHead.Содержание;
	Иначе
		ОбрабатываемыйТекстHTML = ИсходныйТекстHTML;
	КонецЕсли;
	ПереносимоеСодержимоеHead = "";
	
	// Включаем текст style для переноса. Исключение - стиль v8doc-style.
	НайденныйТег = ПолучитьТегВТекстеHTML(ОбрабатываемыйТекстHTML, "style");
	Пока ЗаполненаСтруктураТега(НайденныйТег) Цикл
		Если Найти(НРег(НайденныйТег.ПараметрыОткрывающегоТега), "v8doc-style") = 0 Тогда
			ПереносимоеСодержимоеHead = ПереносимоеСодержимоеHead
				+ Сред(ОбрабатываемыйТекстHTML, НайденныйТег.ПозицияНачалаТега,
					НайденныйТег.ПозицияОкончанияТега - НайденныйТег.ПозицияНачалаТега + 1);
		КонецЕсли;
		НайденныйТег = ПолучитьТегВТекстеHTML(ОбрабатываемыйТекстHTML, "style",
			НайденныйТег.ПозицияОкончанияТега + 1);
	КонецЦикла;
	
	// Включаем текст base для переноса. Исключение - base ИБ.
	НавигационнаяСсылкаИнформационнойБазы = ПолучитьНавигационнуюСсылкуИнформационнойБазы();
	НайденныйТег = ПолучитьТегВТекстеHTML(ОбрабатываемыйТекстHTML, "base");
	Пока ЗаполненаСтруктураТега(НайденныйТег) Цикл
		Если Найти(НРег(НайденныйТег.ПараметрыОткрывающегоТега),
				НРег(НавигационнаяСсылкаИнформационнойБазы)) = 0 Тогда
			ПереносимоеСодержимоеHead =
				ПереносимоеСодержимоеHead
				+ Сред(
					ОбрабатываемыйТекстHTML,
					НайденныйТег.ПозицияНачалаТега,
					НайденныйТег.ПозицияОкончанияТега - НайденныйТег.ПозицияНачалаТега + 1);
		КонецЕсли;
		НайденныйТег = ПолучитьТегВТекстеHTML(ОбрабатываемыйТекстHTML, "base",
			НайденныйТег.ПозицияОкончанияТега + 1);
	КонецЦикла;
	
	// Дописываем сформированное содержимое head в head целевого текста.
	ДобавитьВТегHead(ТекстHTML, ПереносимоеСодержимоеHead);
	
КонецПроцедуры

#КонецОбласти
